---
layout: post
title:  2023-04-29 一篇文章带你了解Java NIO
tagline: by 沉浮
categories: 
tags: 沉浮
---


<!--more-->

## NIO

提到IO，这是Java提供的一套类库，用于支持程序与内存、文件、网络等进行交互，实现数据写入与输出。JDK自从1.4版本后，提供了另一套类库NIO，我们平时习惯称呼为NEW IO或non-blocking IO。

那么这套新的IO库与之前的有何区别？为什么需要这样的IO库呢？

### IO与NIO

NIO相比传统IO，除了提供标准IO的加强功能外，最为核心的是对基于Socket的网络编程提供了一套非阻塞编程支持。

| IO  | NIO  |
|-----|------|
| 面向流 | 面向缓冲 |
| 阻塞  | 非阻塞  |
| 无   | 选择器  |

+ 流与缓冲
  - **Java IO** Java的IO很好的诠释了Stream这个概念，从该单词本身的含义看表示‘河流’，承载数据的流，平时我们说的面向流的操作主要是在流的端点对数据读写的过程。通过Stream相关的API可以看到，
不管是输入还是输出流，我们能做的仅仅是将数据读取或写入到流中。

  - **Java NIO** NIO是基于缓冲区来操作数据，主要是基于通道Channel从Buffer中对数据读取或写入的过程。其中Buffer的灵活性决定了NIO的可操作空间，同样基于Buffer API可以看到，
其提供了对Buffer的基本读写功能外，还有提供了各种其他API来操作Buffer，相比Stream对数据的操作更加的灵活。

+ 阻塞与非阻塞
  - **Java IO** 上面说到IO的操作都是基于流的，往流中写入数据时依赖于OutputStream#write，从流中读取数据时通过InputStream#read，这些操作都是阻塞的。

  - **Java NIO** 支持非阻塞模式，但并非NIO就是非阻塞的，比如基于FileChannel操作文件时，仍然是阻塞的。我们说的阻塞或非阻塞都是基于操作系统层面的read/write方法导致的，NIO的非阻塞
基于操作系统层面提供的多路复用IO模型实现。

### BIO、NIO、AIO

三种模型都有各自适合的使用场景，为高性能网络网络编程提供了强大的支持，基于*网络编程IO模型*来看下这三种IO的差异。

   > BIO方式适用于连接数目比较小且固定的架构，需要依赖于线程来支持多个客户端接入，但程序直观简单易理解。\
   > NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。\
   > AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂。

+ BIO

**同步阻塞IO**，服务端通过阻塞输入流来监听客户端写入的数据，只有当客户端处理完成后才能处理其他客户端的输入。

![bio-simple](/assets/images/2023/sucls/04_29/bio/bio-simple.png)

服务端通过ServerSocket#accept阻塞方法监听客户端的连接，通过阻塞输入流等待客户端的输入，如果一直没有输入，则其他客户端都会被阻塞在此。

![bio-threads](/assets/images/2023/sucls/04_29/bio/bio-threads.png)

我们可以通过多线程来改善，每个客户端连接时，都由独立的线程来处理，虽然通过多线程可以解决客户端间的阻塞问题，但单个线程内然是阻塞模式，并且当客户端过多时需要足够的线程来支持，比较耗费系统资源。

![bio](/assets/images/2023/sucls/04_29/bio/bio-flow.png)

+ NIO

**同步非阻塞IO**，基于多路复用模型，依赖于服务器操作系统，通过一个Selector即可监听多个连接，并进行IO处理。但要注意，如果处理IO的过程较长一样会影响到其他的连接。

![nio](/assets/images/2023/sucls/04_29/nio/nio-simple.png)

服务端通过Selector#select阻塞方法，监听Channel状态，一旦有Channel准备就绪，程序才会继续往下执行，因此需要不断轮询并监控Channel的状态变更。
与BIO的多线程模式非常相似，只不过BIO是基于多线程技术实现，而NIO是基于操作系统底层提供的函数，效率更好且资源消耗更少。

![nio](/assets/images/2023/sucls/04_29/nio/nio-flow.png)

+ AIO

**异步非阻塞IO**，在JDK1.7之后提供了异步的相关Channel，AIO提供异步功能，基于回调函数实现，同样依赖于操作系统底层的异步IO模型，异步操作的实现是在对应的
accept、connection、read、write等方法异步执行，完成后会主动调用回调函数。

![aio](/assets/images/2023/sucls/04_29/aio/aio-simple.png)

其中accept、read等方法都是非阻塞的，即立即返回结果，几乎所有的异步操作都是基于回调函数实现，这种方式不管是对操作系统资源的利用以及效率上都是最佳的实现。

![aio](/assets/images/2023/sucls/04_29/aio/aio-flow.png)


### 同/异步与（非）阻塞

关于阻塞、非阻塞、同步、异步这些名词的解释，可以在网上找到很多解释，但是如何能够从本质上描述其含义，正如IO与NIO中说到的阻塞与非阻塞，又是怎么体现的呢？

+ 同步
  - 调用方法后，等待方法返回才会继续执行

+ 异步
  - 调用方法后立即返回结果，不影响后续流程的执行
  - 而我们所说的异步，其实就是将整个调用过程通过线程发起
  
第一种说法是其实是描述提供方是阻塞或非阻塞

+ 阻塞
  - 一般描述的是线程的状态，在网络编程中的IO阻塞主要是调用操作系统api被阻塞导致程序挂起

+ 非阻塞
  - 在网络编程中，非阻塞主要是基于操作系统底层实现，基于轮询与回调函数，比如多路复用IO模型

> 同步与异步： 很多人说到，这个是客户端的发起的，我们何不再抽象一下，理解为是调用者的行为。
> 阻塞与非阻塞：同样很多任务这是服务端的发生的，我们可以将其理解为提供者的实现的方式。

### NIO相关概念

在NIO中，三个核心的对象Buffer、Channel、Selector

+ Buffer

我们经常说的面向缓存就是这个，Buffer简单的看就是一个内存块，其内部封装了一个数组，同时改对象提供了各种API可以对其操作，包括缓存数据读取与写入、缓存复制等。

其内部结构如下：
![buffer](/assets/images/2023/sucls/04_29/nio/buffer.png)

其内部除了存储数据的数组外，还维护了capacity、limit、position几个属性，用于标记数组容量、存储占用空间、下标索引。Buffer存在读写两种状态，根据上图可以看到其具体含义。
 - capacity

表示Buffer最大可缓存数据的容量。capacity一旦确定，则不可修改；写入数据一旦达到容量，则不可继续写入；

 - limit

在写模式时，limit=capacity，表示buf可写入数据上限。
在读模式时，limit表示buf可读数据上限。

 - position

表示Buffer数组下标位置。初始化时，position=0；
   * 写模式
  （1）在刚进入写模式时，position为0，表示当前的写入位置为从头开始。
  （2）当有数据写入到缓冲区后，position会向后移动写入数量个位置。
  （3）初始的position值为0，最大可写值为limit。当position值达到limit时，缓冲区就已经无空间可写了。
   * 读模式
  （1）当缓冲区刚开始进入读模式时，position会被重置为0。
  （2）当从缓冲区读取时，也是从position位置开始读。读取数据后，position向前移动到下一个可读的位置。
  （3）在读模式下，limit表示可读数据的上限。position的最大值为最大可读上限limit，当position达到limit时表明缓冲区已经无数据可读。

 - flip

用于将Buffer由写状态切换为读状态，limit = position; position = 0;

![flip](/assets/images/2023/sucls/04_29/nio/flip.png)

- compact、clear

用于将Buffer由读状态切换为写状态，compact：position=limit，limit=capacity; clear：position=0，limit=capacity。

![compact](/assets/images/2023/sucls/04_29/nio/compact.png)

![clear](/assets/images/2023/sucls/04_29/nio/clear.png)

 - mark、reset

操作buf时，用于临时存储position（mark=position），当有需要时，可以通过rest方法将临时值取出并赋值到position（position=mark）
重新从标记位置继续操作buf。

+ Channel  
直译为通道，表示源端与目标端的连接通道，主要负责将数据读写到Buffer。
  - 通道可以同时进行读写，而流只能读或者只能写
  - 通道可以实现异步读写数据
  - 通道可以从缓冲读数据，也可以写数据到缓冲;

常用的Channel包括FileChannel、DatagramChannel、ServerSocketChannel和SocketChannel。
  - **FileChannel** 用于文件的数据读写，
  - **DatagramChannel** 用于 UDP 的数据读写，
  - **ServerSocketChannel**和**SocketChannel** 用于 TCP 的数据读写。

+ Selector  
对接操作系统select


### 示例

1. 文件复制

传统IO复制文件时需要依赖于InputStream、OutputStream来完成，基于NIO可以通过FileChannel：
```
sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);

// 其中获取FileChannel的方法有一下三种：
FileChannel channel = new FileInputStream(file).getChannel();
        FileChannel channel = new FileOutputStream(file).getChannel();

FileChannel  channel = new RandomAccessFile(file, "rw").getChannel();

        FileChannel fileChannel = FileChannel.open(file.toPath());
```

3. 基于UDP协议的数据传输

Server:
```
@Slf4j
public class Server {

    private Selector selector;
    private DatagramChannel datagramChannel;

    public Server(int port) {
        try {
            this.selector = Selector.open();

            this.datagramChannel = DatagramChannel.open();
            this.datagramChannel.configureBlocking(false);
            this.datagramChannel.bind(new InetSocketAddress(port));

            this.datagramChannel.register(this.selector, SelectionKey.OP_READ);

            log.info("++++++ DUP Server启动成功 ++++++");
        } catch (IOException e) {
            log.error("Server创建失败：{}", e.getMessage());
        }
    }

    public void start() throws IOException {
        while (true){
            int select = selector.select();
            if(select >0 ){
                Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();
                while (iterator.hasNext()){
                    SelectionKey key = iterator.next();
                    iterator.remove();

                    if(key.isReadable()){
                        DatagramChannel channel = (DatagramChannel) key.channel();
                        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
                        channel.receive(byteBuffer);

                        byteBuffer.flip();
                        CharBuffer charBuffer = Charset.defaultCharset ().decode ( byteBuffer ) ;
                        log.info("Server接收消息：{}",  charBuffer);
                    }
                }
            }
        }
    }
}
```

Client:
```java
@Slf4j
public class Client {

    private DatagramChannel datagramChannel;

    public Client(int port) {
        try {
            this.datagramChannel = DatagramChannel.open();
            this.datagramChannel.configureBlocking(true);
            this.datagramChannel.connect(new InetSocketAddress("127.0.0.1", port));
        } catch (IOException e) {
            log.error("Client创建失败：{}", e.getMessage());
        }
    }

    public void invoke(String message) throws IOException {
        log.info("Client发送消息：{}", message);
        datagramChannel.write(Charset.defaultCharset().encode(message));
    }
}
```

Tests:
```java
public class UDPTest {

    int port = 8095;

    @Test
    public void server() throws IOException {
        Server server = new Server(port);
        server.start();
    }

    @Test
    public void client() throws IOException {
        Client client = new Client(port);
        client.invoke(message);
        while (true){}
    }
}
```

5. Socket示例

+ NIO示例

Server:
```java
@Slf4j
public class Server {

    private ServerSocketChannel serverSocketChannel;
    private Selector selector;

    public Server(int port){
        try {
            this.selector = Selector.open();

            this.serverSocketChannel = ServerSocketChannel.open();
            serverSocketChannel.configureBlocking(false);

            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            serverSocketChannel.bind(new InetSocketAddress(port));

            log.info("++++++ NIO Server启动成功 ++++++");
        } catch (IOException e) {
            log.error("创建ServerSocketChannel出错：{}", e.getMessage());
        }
    }

    public void start() throws IOException {
        while (true){
            selector.select(); // 阻塞
            Iterator<SelectionKey> keyIterator = selector.selectedKeys().iterator();
            while (keyIterator.hasNext()){
                SelectionKey selectionKey = keyIterator.next();
                keyIterator.remove(); //
                if(!selectionKey.isValid()){
                    continue;
                }
                if(selectionKey.isAcceptable()){
                    ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();
                    SocketChannel socketChannel = ssc.accept(); // 可以是阻塞或非阻塞，获取的Channel一定是阻塞的
                    socketChannel.configureBlocking(false); // 这个有用？

                    socketChannel.register(selector, SelectionKey.OP_READ);
                }else if(selectionKey.isReadable()){
                    SocketChannel channel = (SocketChannel) selectionKey.channel();
                    ByteBuffer buffer = ByteBuffer.allocate(256);
                    int writeBytes = channel.read(buffer); //
                    if(writeBytes > 0){
                        buffer.flip();
                        byte[] bytes = new byte[buffer.remaining()];
                        buffer.get(bytes);
                        log.info(">>> Server接收消息：{}", new String(bytes));
                    }
                    // 回复
                    channel.write(Charset.defaultCharset().encode("我是Server的回复内容"));
                }
            }
        }
    }
}
```

Client:
```java
@Slf4j
public class Client {

    private SocketChannel socketChannel;

    public Client(int port){
        try {
            this.socketChannel = SocketChannel.open();
            socketChannel.connect(new InetSocketAddress("127.0.0.1",port));
        } catch (IOException e) {
            log.error("创建SocketChannel出错：{}", e.getMessage());
        }
    }

    public void invoke(String message) throws IOException {
        log.info(">>> Client发送消息：{}", message);
        this.socketChannel.write(Charset.defaultCharset().encode(message));
    }

}
```

+ AIO示例

Server:
```java
@Slf4j
public class Server {

    private AsynchronousServerSocketChannel serverSocketChannel;

    private volatile boolean start;

    public Server(int port) {
        try {
            //
            serverSocketChannel = AsynchronousServerSocketChannel.open();
            //绑定端口
            serverSocketChannel.bind(new InetSocketAddress(port));

            start = true;
            log.info("++++++ AIO Server启动成功 ++++++");
        } catch (IOException e) {
            log.error("Server创建失败：{}", e.getMessage());
        }
    }

    /**
     *
     */
    public void start(){
        //异步接收客户端连接
        serverSocketChannel.accept(null, new AcceptCompletionHandler<String>());
        while (start){ }
    }

    /**
     * 处理客户端连接
     * @param <T>
     */
    public class AcceptCompletionHandler<T> implements CompletionHandler<AsynchronousSocketChannel,T> {

        @Override
        public void completed(AsynchronousSocketChannel result, T attachment) {
            log.info(">>> 客户端接入...");
            ByteBuffer byteBuffer = ByteBuffer.allocate(512);
            //异步读客户端数据
            result.read(byteBuffer, byteBuffer, new ReadCompletionHandler());
            //接收其他的客户端连接的
            serverSocketChannel.accept(null, this);
        }

        @Override
        public void failed(Throwable exc, T attachment) {
            log.error(">>> 客户端接入失败:{}", exc.getMessage());
        }
    }

    /**
     * 处理ServerChannel读取
     * @param <T>
     */
    public class ReadCompletionHandler<T extends Buffer> implements CompletionHandler<Integer, T>{

        @Override
        public void completed(Integer result, T attachment) {
            if(attachment.hasRemaining()){
                // 切换成读模式
                attachment.flip();
                //
                if( attachment instanceof ByteBuffer ){
                    byte[] bytes = new byte[attachment.remaining()];
                    ((ByteBuffer)attachment).get(bytes); // 从Buffer中取数据 get
                    log.info("Server接收消息：{}", new String(bytes));
                }
            }
        }

        @Override
        public void failed(Throwable exc, T attachment) {
            log.error("Server接收消息失败：{}", exc.getMessage());
        }
    }
}
```

Client:
```java
@Slf4j
public class Client {

    private AsynchronousSocketChannel socketChannel;

    public Client(int port) {
        try {
            //创建异步通道实例
            socketChannel = AsynchronousSocketChannel.open();
            //连接服务端，异步方式
            socketChannel.connect(new InetSocketAddress("127.0.0.1",port), null, new ConnetionComplateHandler());
        } catch (IOException e) {
            log.error("Client创建失败：{}", e.getMessage());
        }
    }

    /**
     *
     * @param message
     */
    public void invoke(String message){
        log.info("Client发生消息：{}", message);
        this.socketChannel.write(Charset.defaultCharset().encode(message));
    }

    /**
     *
     * @param <T>
     */
    public class ConnetionComplateHandler<T> implements CompletionHandler<Void, T> {

        @Override
        public void completed(Void result, T attachment) {
            log.info("Client连接服务的成功...");
        }

        @Override
        public void failed(Throwable exc, T attachment) {

        }
    }
}
```

NIO整体处理流程如下：
1. 通过Selector.open()获取Selector
2. 通过ServerSocketChannel.open()获取ServerSocketChannel
3. 设置ServerSocketChannel为非阻塞模式，ServerSocketChannel.configureBlocking(false)
4. 将Channel绑定到Selector上，并定义关注的操作类型， serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT)
5. 将ServerSocketChannel绑定Socket，并设定监听端口，ServerSocketChannel.bind(new InetSocketAddress(port))
6. 开始轮询Selector
7. 阻塞Selector.select()，直到有准备就绪的Channel
8. 轮询Selector.selectedKeys()，获取这些Channel
9. 基于SelectionKey，按需要可以对当前Channel进行Accept、Read、Write等操作
10. 比如当接收客户端链接时，需要将该Channel注册到Selector；

### 零拷贝

*零拷贝的“零”是指用户态和内核态间copy数据的次数为零*

要知道，如果用户需要读取系统中的文件，是没办法直接读取磁盘内容，必须调用操作系统提供的系统API从内核缓冲区将文件数据拷到用户缓冲区后才能读取到
文件信息。

在操作系统层面，如果为了完成网络文件的传输，大概需要经历下面这些过程：
```
while( in.read(...)!=-1 ){
   out.write(...) 
}
```

![nio-file](/assets/images/2023/sucls/04_29/nio/read-file.png)

整个过程经历了4次文件拷贝：
1. 读取磁盘文件到操作系统内核缓冲区
2. 将内核缓冲区的数据，copy 到应用程序的 buffer
3. 将应用程序 buffer 中的数据，copy 到 socket 网络发送缓冲区
4. 将 socket buffer 的数据，copy 到网卡，由网卡进行网络传输

经历了4次CPU切换：
1. 程序调用系统api将文件从磁盘读取到内核态缓冲区，用户态切换内核态
2. 将数据由内核态缓冲区拷贝到用户缓冲区，内核态切换用户态
3. 程序调用系统api将数据由用户缓冲区拷贝到内核缓冲区，用户态切换内核态
4. 将数据由内核态缓冲区拷贝到网卡，内核态切换用户态

在高并发网络通信环境中，通过传统的方式由于多次的CPU切换与数据拷贝会消耗系统资源，因此为了提高网络间文件传输的性能，就需要减少‘用户态与内核态的上下文切换’和‘内存拷贝’的次数。

---
零拷贝依附于操作系统底层，基于虚拟内存实现，将文件地址与虚拟地址件建立映射关系，

![zero-copy](/assets/images/2023/sucls/04_29/nio/zero-copy.png)

零拷贝技术可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效地提高数据传输效率
零拷贝技术减少了用户进程地址空间和内核地址空间之间因为上:下文切换而带来的开销

+ MappedByteBuffer

```
    RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rw");
    FileChannel fileChannel = randomAccessFile.getChannel();
    MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, fileChannel.size());
```

+ DirectByteBuffer

DirectByteBuffer继承了MappedByteBuffer，主要是实现了byte获得函数get等
```java

```

+ 零拷贝问题

（1）直接内存DirectMemory的大小默认为 -Xmx 的JVM堆的最大值，但是并不受其限制，而是由JVM参数 MaxDirectMemorySize单独控制。
（2）直接内存不是分配在JVM堆中。并且直接内存不受 GC(新生代的Minor GC)影响，只有当执行老年代的 Full GC时候才会顺便回收直接内存！而直接内存是通过存储在JVM堆中的DirectByteBuffer对象来引用的，
所以当众多的DirectByteBuffer对象从新生代被送入老年代后才触发了 full gc。
（3）MappedByteBuffer在处理大文件时的确性能很高，但也存在一些问题，如内存占用、文件关闭不确定，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。

### 结束语

  NIO的出现得益于操作系统级别的变革，由于网路编程对性能与资源使用上的要求更高，传统的IO模型只能通过线程来提升系统吞吐率

### 参考

[异步阻塞](https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw)

[IO阻塞与非阻塞](https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw)

[IO多了复用](https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw)